### 数组
## 通过数组可以完成  队列，  （先进先出 Queue） （栈  Stack）
1. every (callback(element, index ,array) , thisArg); // 如果所以的callback函数都返回true ， 则结果为true  否则为false
2. fill (value , startIndex , endIndex); 填充数组 返回填充后的对象 并且改变当前调用对象的修改
3. filter(callback(element, index, array) , thisArg); / / 测试数组的每一个 元素如果为true  那么保留在新数组中， 为false就剔
除
4. find (callback(element, index, array), thisArg); // 返回满足函数的第一个元素的值
5. findIndex (callback(element, index, array), this.Arg); // 返回满足函数的第一个元素的下标
6. includes(valueToFind, fromIndex); // 寻找数组中是否存在该元素， 从起始下标开始 默认是 0 ； 存在返回true， 不存在返回false
7. reduce(callback(accumulator, currentValue, currentIndex, array), this.Arg);  // 升序对每一个元素执行 callback函数， 并最终返回一个结果

### 链表
* 链表
* 双向链表
* 循环链表  (前驱 和 后继实现首尾相连)

### 集合 : 的实现是基于 对象的， 也可以使用数组实现
### 字典 : 即java中 Map
### 散列表 : 即java中的hashMap ， hashTable
* 散列表冲突 ：
1. 链表法： 在对应hash值位置增加链表来存储键值对
2. 线性查找 ： 如果索引位置被占用就 +1 一直到有空的位置为止
3. 实现更好的散列函数
```
var djb2HashCode = function (key) {
    var hash = 5381; //{1}
    for (var i = 0; i < key.length; i++) { //{2}
        hash = hash * 33 + key.charCodeAt(i); //{3}
    }
    return hash % 1013; //{4}
};
```
## 除了Set和Map这两种新的数据结构， ES6还增加了它们的弱化版本， WeakSet和WeakMap(使用对象作为键)
## 树 ： 搜索二叉树， 平衡二叉树
## 图: 是一组由边连接的节点（顶点)
1. 由一条边连接在一起的顶点 称为 **相邻顶点**
2. 一个节点到另外其他节点的边数称为 **度**
3. 相邻顶点连接的一个连续的序列 称为 **路径**
4. 不包括重复顶点的路径 称为 **简单路径**
5. 通过一个顶点为起始点连接其他路劲最后回到该顶点的路劲称为 **环**
6. 如果图中不存在环 那么该图称为 **无环图**
7. 如果图中每两个顶点都有一条边 **连通图**
8. 图分为 **有向图**  ， **无向图**
9. 如果图中每两个顶点在双向上都存在方向， **强连通图**
10. 图还分为 **加权图**（边被赋予了权值的就是加权图) ， **未加全图**
## 邻接矩阵(1 表示存在边  0表示不存在)
![邻接矩阵(1 表示存在边  0表示不存在)](./邻接矩阵.png)
**缺点 ：**
1. 如果邻接矩阵不是强连通的图（稀疏矩阵) 那么用邻接矩阵表示， 矩阵中将会存在很多0， 这表示计算机浪费存储空间来记录根本不存在的边
2. 即使只有一个邻接节点 也会迭代一行
3. 如果图中的顶点数不是固定的那么， 动态增加二维数组不太灵活    

## 邻接表 （可以使用数组， 链表， 甚至散列表，字典来表示相邻顶点列表)
![](./邻接表.png)
> 在查看两个点是否相邻的时候 使用邻接矩阵是最快的  [w][v]

### 图的遍历 （广度优先， 深度优先) 【每个顶点必须访问两次】
> 搜索的顶点存在三种状态 ： 1. 还没有访问过 2. 访问过，但是没有搜索 3.访问过，完全搜索过
## 深度优先 ： 使用的是栈的结构存储顶点
## 广度优先 ： 使用的是队列存储顶点
1. 会先搜索相邻的节点， 先宽后深 ， 这也是名字的由来

